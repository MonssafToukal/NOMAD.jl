var documenterSearchIndex = {"docs":
[{"location":"nomadResults/#Results-1","page":"Results","title":"Results","text":"","category":"section"},{"location":"nomadResults/#","page":"Results","title":"Results","text":"Main results from a NOMAD optimization process are stored in an object of the type described below.","category":"page"},{"location":"nomadResults/#","page":"Results","title":"Results","text":"nomadResults","category":"page"},{"location":"nomadResults/#NOMAD.nomadResults","page":"Results","title":"NOMAD.nomadResults","text":"nomadResults\n\nmutable struct containing info about a NOMAD run, returned by the method nomad(eval,param).\n\nTo display the info contained in a object result::nomadResults, use :\n\ndisp(result)\n\nAttributes :\n\nbest_feasible::Vector{Float64} :\n\nFeasible point found by NOMAD that best minimizes the objective function.\n\nbbo_best_feasible::Vector{Float64} :\n\nOutputs of eval(x) for the best feasible point.\n\nbest_infeasible::Vector{Float64} :\n\nInfeasible point found by NOMAD that best minimizes the objective function.\n\nbbo_best_infeasible::Vector{Float64} :\n\noutputs of eval(x) for the best infeasible point.\n\nbb_eval::Int64 :\n\nNumber of eval(x) evaluations\n\ninter_states::Matrix{Float64} :\n\nList of improving intermediate states evaluated during the optimization process. It is a matrix of which the lines correspond to successive states that are browsed. Each column correspond to a dimension.\n\ninter_bbo::Vector{Float64} :\n\nList of black box outputs corresponding to intermediate states available in interstates. It is a matrix of which the lines correspond to successive states that are browsed. Each column correspond to an output (same order as defined in nomadParameters.outputtypes).\n\ninter_bbe::Vector{Int64} :\n\nList of black box evaluations numbers required to reach each of the states available in inter_states.\n\nstat_avg::Float64 :\n\nStatistic average computed during optimization.\n\nstat_sum::Float64 :\n\nStatistic sum computed during optimization.\n\nseed::Float64 :\n\nRandom seed used for the run.\n\n\n\n\n\n","category":"type"},{"location":"surrogates/#Surrogates-1","page":"Surrogates","title":"Surrogates","text":"","category":"section"},{"location":"surrogates/#","page":"Surrogates","title":"Surrogates","text":"The current version of NOMAD.jl supports use of static surrogates which are not updated during the run and which are provided by the user. A surrogate provides approximations of the black box outputs and is typically less time-consuming to evaluate. Hence, their use allows to speed up the optimization process.","category":"page"},{"location":"surrogates/#","page":"Surrogates","title":"Surrogates","text":"Such surrogates can be provided to NOMAD.jl as simple Function objects of the following form :","category":"page"},{"location":"surrogates/#","page":"Surrogates","title":"Surrogates","text":"(success, count_eval, sgte_outputs) = surrogate(x :: Vector{Number})","category":"page"},{"location":"surrogates/#","page":"Surrogates","title":"Surrogates","text":"The surrogate needs to return the same number of outputs as the function eval(x), with the same types and in the same order. Just like for eval(x), count_eval is a Bool determining if the evaluation has to be taken into account, and success is a Bool equal to false if the evaluation failed.","category":"page"},{"location":"surrogates/#","page":"Surrogates","title":"Surrogates","text":"You can directly provide it to the function nomad() as an optional argument. The corresponding method is :","category":"page"},{"location":"surrogates/#","page":"Surrogates","title":"Surrogates","text":"nomad(eval :: Function, param :: nomadParameters; surrogate :: Function)","category":"page"},{"location":"surrogates/#","page":"Surrogates","title":"Surrogates","text":"which returns an object of type nomadResults.","category":"page"},{"location":"surrogates/#","page":"Surrogates","title":"Surrogates","text":"The cost of the surrogate can be set via the attribute sgte_cost of the nomadParameters provided to nomad(). More precisely, sgte_cost is the number of surrogate evaluations costing as much as one black box evaluation. If set to 0, a surrogate evaluation is considered as free. It is set to 0 by default.","category":"page"},{"location":"run_nomad/#Run-the-optimization-1","page":"Run Optimization","title":"Run the optimization","text":"","category":"section"},{"location":"run_nomad/#","page":"Run Optimization","title":"Run Optimization","text":"A NOMAD optimization process can be run by using the nomad() method described below.","category":"page"},{"location":"run_nomad/#","page":"Run Optimization","title":"Run Optimization","text":"nomad(eval :: Function, param :: nomadParameters)","category":"page"},{"location":"run_nomad/#NOMAD.nomad-Tuple{Function,nomadParameters}","page":"Run Optimization","title":"NOMAD.nomad","text":"nomad(eval::Function,param::nomadParameters)\n\n-> Run NOMAD with settings defined by param and an optimization problem defined by eval.\n\n-> Display stats from NOMAD in the REPL.\n\n-> return an object of type nomadResults that contains info about the run.\n\nArguments :\n\neval::Function\n\na function of the form :\n\n(success,counteval,bboutputs)=eval(x::Vector{Number})\n\nbb_outputs being a vector{Number} containing the values of objective function and constraints for a given input vector x. NOMAD will seak to minimize the objective function and keeping constraints inferior to 0.\n\nsuccess is a Bool set to false if the evaluation failed.\n\ncount_eval is a Bool equal to true if the black box evaluation counting has to be incremented. Note that statistic sums and averages are updated only if count_eval is equal to true.\n\nparam::nomadParameters\n\nAn object of type nomadParameters of which the attributes are the settings of the optimization process (dimension, output types, display options, bounds, etc.).\n\nExample :\n\nusing NOMAD\n\nfunction eval(x)       f=x[1]^2+x[2]^2       c=1-x[1]       success=true       counteval=true       bboutputs = [f,c]       return (success,counteval,bboutputs)   end\n\nparam = nomadParameters([5,5],[\"OBJ\",\"EB\"])   #=first element of bb_outputs is the objective function (\"OBJ\"), second is a     constraint treated with the Extreme Barrier method (\"EB\"). Initial point     for optimization is [5,5]=#\n\nresult = nomad(eval,param)\n\ndisp(result)\n\n\n\n\n\n","category":"method"},{"location":"nomadParameters/#Parameters-setting-1","page":"Parameters","title":"Parameters setting","text":"","category":"section"},{"location":"nomadParameters/#","page":"Parameters","title":"Parameters","text":"The settings of a NOMAD optimization process must be entered in an object of the type described below.","category":"page"},{"location":"nomadParameters/#","page":"Parameters","title":"Parameters","text":"nomadParameters","category":"page"},{"location":"nomadParameters/#NOMAD.nomadParameters","page":"Parameters","title":"NOMAD.nomadParameters","text":"nomadParameters\n\nmutable struct containing the options of the optimization process.\n\nConstructors :\n\nClassic constructor :\np1 = nomadParameters(x0::AbstractVector,output_types::Vector{String})\nCopy constructor (deepcopy):\np1 = nomadParameters(p2)\n\nAttributes :\n\nx0::AbstractVector :\n\nInitialization point for NOMAD. Needs to be of dimension n<=1000. It can be either a unique Vector{Number} to provide only one initial point or a vector of several Vector{Number} to provide several initial points. No default value, needs to be set.\n\noutput_types::Vector{String} :\n\nA vector containing String objects that define the types of outputs returned by eval (the order is important) :\n\nString Output type\n\"OBJ\" objective value to be minimized\n\"PB\" or \"CSTR\" progressive barrier constraint\n\"EB\" extreme barrier constraint\n\"F\" filter approach constraint\n\"PEB\" hybrid constraint EB/PB\n\"STAT_AVG\" Average of this value will be computed for all blackbox calls (must be unique)\n\"STAT_SUM\" Sum of this value will be computed for all blackbox calls (must be unique)\n\"NOTHING\" or \"-\" The output is ignored\n\nPlease note that F constraints are not compatible with CSTR, PB or PEB. However, EB can be combined with F, CSTR, PB or PEB. No default value, needs to be set.\n\nlower_bound::Vector{Number} :\n\nLower bound for each coordinate of the state. If empty, no bound is taken into account. [] by default.\n\nupper_bound::Vector{Number} :\n\nUpper bound for each coordinate of the state. If empty, no bound is taken into account. [] by default.\n\ndisplay_all_eval::Bool :\n\nIf false, only evaluations that allow to improve the current state are displayed. false by default.\n\ndisplay_stats::String :\n\nString defining the way outputs are displayed (it should not contain any quotes). Here are examples of keywords that can be used :\n\nKeyword Display\nbbe black box evaluations\nobj objective function value\nsol solution\nbbo black box outputs\nmesh_index mesh index parameter\nmesh_size mesh size parameter\ncons_h Infeasibility\npoll_size Poll size parameter\nsgte Number of surrogate evaluations\nstat_avg AVG statistic defined in output types\nstat_sum SUM statistic defined in output types\ntime Wall-clock time\n\n\"bbe ( sol ) obj\" by default.\n\ndisplay_degree::Int :\n\nInteger between 0 and 3 that sets the level of display. 2 by default.\n\nmax_bb_eval::Int :\n\nMaximum of calls to eval allowed. if equal to zero, no maximum is taken into account. 0 by default.\n\nmax_time::Int :\n\nmaximum wall-clock time (in seconds). if equal to zero, no maximum is taken into account. 0 by default.\n\noutput_types::Vector{String} :\n\nA vector containing String objects that define the types of inputs to be given to eval (the order is important) :\n\nString Input type\n\"R\" Real/Continuous\n\"B\" Binary\n\"I\" Integer\n\nall R by default.\n\n-sgte_cost::Int : number of surrogate evaluations costing as much as one black box evaluation. If set to 0, a surrogate evaluation is considered as free. 0 by default.\n\nLH_init::Int :\n\nnumber of initial search points performed with Latin-Hypercube method. 0 by default.\n\nLH_iter::Int :\n\nnumber of search points performed at each iteration with Latin-Hypercube method. 0 by default.\n\nopportunistic_LH::Bool :\n\nIf true, the Latin-Hypercube search stops as soon as a better point is found. true by default.\n\nVNS_search::Bool :\n\nThe Variable Neighborhood Search (VNS) is a strategy to escape local minima. It is based on the Variable Neighborhood Search metaheuristic. VNS should only be used for problems with several such local optima. It will cost some additional evaluations, since each search performs another MADS run from a perturbed starting point. Though, it will be a lot cheaper if a surrogate is provided. false by default\n\ngranularity::Vector{Float} :\n\nThe granularity of input variables, that is to say the minimum variation authorized for these variables. A granularity of 0 corresponds to a real variable. by default, 0 for real variables, 1 for integer and binary ones.\n\nstop_if_feasible::Bool :\n\nIf set to true, NOMAD terminates when it generates a first feasible solution. false by default.\n\nstat_sum_target::Number :\n\nNOMAD terminates if STAT_SUM reaches this value. Inf by default.\n\nseed::Bool :\n\nrandom seed used by NOMAD. If set to -1, the seed of each run will be different. 0 by default.\n\n\n\n\n\n","category":"type"},{"location":"#Home-1","page":"Home","title":"NOMAD.jl documentation","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"This package provides a Julia interface for NOMAD, which is a C++ implementation of the Mesh Adaptive Direct Search algorithm (MADS), designed for difficult blackbox optimization problems. These problems occur when the functions defining the objective and constraints are the result of costly computer simulations.","category":"page"},{"location":"#Type-of-problems-treated-1","page":"Home","title":"Type of problems treated","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"NOMAD allows to deal with optimization problems of the form :","category":"page"},{"location":"#","page":"Home","title":"Home","text":"beginarrayrrcll\n  (BB)   \n  displaystyle min_x  f(x)\n  st\n                  c_i(x)  leq 0      forall i = 1  m\n   ell_j leq  x_j   leq u_j  forall j = 1  n\nendarray","category":"page"},{"location":"#","page":"Home","title":"Home","text":"where fmathbbR^nrightarrowmathbbR, cmathbbR^nrightarrowmathbbR^m, and ell_j u_j in mathbbRcuppminfty for j = 1dotsn.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The functions f and c_i are typically blackbox functions of which evaluations require computer simulation.","category":"page"},{"location":"#Quick-start-1","page":"Home","title":"Quick start","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"It is first needed to declare a function eval(x :: Vector{Float64}) that returns two booleans and a Vector{Float64} that contains the objective function and constraints evaluated for x.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"function eval(x)\n  f = x[1]^2 + x[2]^2\n  c = 1 - x[1]\n  success = true\n  count_eval = true\n  bb_outputs = [f, c]\n  return (success, count_eval, bb_outputs)\nend","category":"page"},{"location":"#","page":"Home","title":"Home","text":"success is a Bool that should be set to false if the evaluation failed. count_eval is a Bool that should be equal to true if the black box evaluation counting has to be incremented.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Then an object of type nomadParameters has to be created, it will contain options for the optimization. The arguments of its constructor are the initial point x0 and the types of the outputs contained in bb_outputs.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"param = nomadParameters([3, 3], [\"OBJ\", \"EB\"])\nparam.lower_bound = [-5, -5]\nparam.upper_bound = [5, 5]","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Here, first element of bb_outputs is the objective function (f), second is a constraint treated with the Extreme Barrier method (c). In this example, lower and upper bounds have been added but it is not compulsory.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Now the function nomad() can be called with these arguments to launch a NOMAD optimization process.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"result = nomad(eval, param)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The object of type nomadResults returned by nomad contains information about the run. Use the function disp(result :: nomadResults) to display this info.","category":"page"}]
}
